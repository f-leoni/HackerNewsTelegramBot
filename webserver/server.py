#!/usr/bin/env python3
"""
HTTPS server to serve bookmarks from an SQLite database - Enhanced Version
"""
import os
import sqlite3
import ssl
import json
import re
import logging
from http.server import HTTPServer, BaseHTTPRequestHandler
from http.cookies import SimpleCookie
from urllib.parse import urlparse, parse_qs
import socket
import sys
from contextlib import contextmanager
import secrets
from datetime import datetime, timedelta
from werkzeug.security import check_password_hash

# Add the project root to the path to import the shared library
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
sys.path.append(os.path.dirname(SCRIPT_DIR))

from shared.utils import extract_domain, get_article_metadata
from shared.database import get_db_path
from htmldata import get_html
from htmldata import get_login_page
__version__ = "1.6.2"

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Configuration

# Default
DB_PATH = get_db_path()
PORT = 8443

@contextmanager
def db_connection():
    """Context manager to handle database connections safely."""
    conn = sqlite3.connect(DB_PATH)
    try:
        yield conn.cursor()
        conn.commit()
    finally:
        conn.close()

class BookmarkHandler(BaseHTTPRequestHandler):
    def version_string(self):
        """Overrides the 'Server' header to not reveal the software version."""
        return "Web Server"

    def get_current_user(self):
        """Verifies the session cookie and returns the user ID if valid."""
        cookies = SimpleCookie(self.headers.get('Cookie'))
        session_id = cookies.get('session_id')

        if not session_id:
            return None

        with db_connection() as cursor:
            cursor.execute(
                "SELECT user_id FROM sessions WHERE session_id = ? AND expires_at > ?",
                (session_id.value, datetime.now())
            )
            result = cursor.fetchone()

        return result[0] if result else None

    def _send_security_headers(self):
        """Adds common security headers to all responses."""
        self.send_header('Strict-Transport-Security', 'max-age=31536000; includeSubDomains')
        self.send_header('Referrer-Policy', 'strict-origin-when-cross-origin')
        self.send_header('X-Content-Type-Options', 'nosniff')
        # CSP: Allow resources from the same domain, images from https, and inline styles/scripts.
        # 'unsafe-inline' is necessary for dynamically managed styles and scripts.
        csp = "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self'; form-action 'self';"
        self.send_header('Content-Security-Policy', csp)

    def _redirect(self, path):
        """Sends a 302 redirect response."""
        self.send_response(302)
        self._send_security_headers()
        self.send_header('Location', path)
        self.end_headers()

    def _send_html_response(self, status_code, html_content):
        """Helper to send HTML responses."""
        self.send_response(status_code)
        self._send_security_headers()
        self.send_header('Content-type', 'text/html; charset=utf-8')
        self.end_headers()
        self.wfile.write(html_content.encode('utf-8'))

    def do_AUTHHEAD(self):
        """Dummy method to handle non-standard authentication requests."""
        self.send_response(401)
        self._send_security_headers()
        self.send_header('WWW-Authenticate', 'Basic realm=\"Test\"')
        self.send_header('Content-type', 'text/html')
        self.end_headers()

    def do_GET(self):
        """
        Handles GET requests.

        Supported routes:
          - /                 -> main page (HTML generated by get_html)
          - /api/bookmarks     -> JSON API that returns the list of bookmarks
          - /favicon.ico       -> responds 404

        Effect: analyzes self.path, calls the corresponding service method
        and sends the HTTP response with the appropriate code and headers.
        Responds 404 for unknown paths.
        """
        path = urlparse(self.path).path

        if path == '/login':
            self.serve_login_page()
            return
        elif path == '/logout':
            self.handle_logout()
            return

        # Allow access to static files without authentication
        if path.startswith('/static/'):
            self.serve_static_file()
            return

        # Protect all other routes
        user_id = self.get_current_user()
        if not user_id:
            self._redirect('/login')
            return

        if path == '/':
            self.serve_homepage()
        elif path == '/api/bookmarks':
            query_components = parse_qs(urlparse(self.path).query)
            limit = int(query_components.get("limit", [20])[0]) # noqa
            offset = int(query_components.get("offset", [0])[0]) # noqa
            filter_type = query_components.get("filter", [None])[0] # noqa
            search_query = query_components.get("search", [None])[0]
            hide_read = query_components.get("hide_read", ['false'])[0].lower() == 'true'
            self.serve_bookmarks_api(limit=limit, offset=offset, filter_type=filter_type, hide_read=hide_read, search_query=search_query)
        else:
            self._send_error_response(404, "Not Found")

    def do_POST(self):
        """
        Handles POST requests.

        Currently only supports the route:
          - POST /api/bookmarks  : adds a new bookmark by reading JSON from the body

        Responds with 404 if the path is not recognized.
        """
        path = urlparse(self.path).path

        if path == '/login':
            self.handle_login()
            return

        # Protect all other routes
        user_id = self.get_current_user()
        if not user_id and path != '/login':
            self._send_error_response(401, "Authentication required")
            return

        if path == '/api/bookmarks':
            self.add_bookmark()
        elif path == '/api/scrape':
            self.scrape_metadata()
        else:
            self._send_error_response(404, "Not Found")

    def do_PUT(self):
        """
        Handles PUT requests to update existing resources.

        Supports:
          - PUT /api/bookmarks/<id>        -> updates bookmark fields (calls update_bookmark)
          - PUT /api/bookmarks/<id>/read   -> sets the "is_read" flag (calls mark_read)

        The method parses the path to extract the id. If the id is not
        an integer, it responds with 400. If the route is not recognized, it responds with 404.
        """
        logger.info(f"PUT request for: {self.path}")

        user_id = self.get_current_user()
        if not user_id:
            self._send_error_response(401, "Authentication required")
            return

        parts = urlparse(self.path).path.strip('/').split('/')

        # Supports: /api/bookmarks/<id>  (update)
        # and /api/bookmarks/<id>/read (set read flag)
        if len(parts) >= 3 and parts[0] == 'api' and parts[1] == 'bookmarks':
            try:
                bookmark_id = int(parts[2])
            except ValueError:
                self._send_error_response(400, "Invalid bookmark ID")
                return

            if len(parts) == 4 and parts[3] == 'read':
                self.mark_read(bookmark_id)
            else:
                self.update_bookmark(bookmark_id)
        else:
            self._send_error_response(404, "Not Found")

    def do_DELETE(self):
        """
        Handles DELETE requests.

        Supported route:
          - DELETE /api/bookmarks/<id>  -> deletes the bookmark with the specified id

        Parses the id from the path; if it's invalid, it responds with 400.
        On success, it calls delete_bookmark which sends the JSON response.
        """
        logger.info(f"DELETE request for: {self.path}")

        user_id = self.get_current_user()
        if not user_id:
            self._send_error_response(401, "Authentication required")
            return

        parts = urlparse(self.path).path.strip('/').split('/')

        # Supports: /api/bookmarks/<id>
        if len(parts) == 3 and parts[0] == 'api' and parts[1] == 'bookmarks':
            try:
                bookmark_id = int(parts[2])
            except ValueError:
                self._send_error_response(400, "Invalid bookmark ID")
                return

            self.delete_bookmark(bookmark_id)
        else:
            self._send_error_response(404, "Not Found")

    def serve_login_page(self):
        """Serves the HTML login page."""
        self._send_html_response(200, get_login_page())

    def handle_login(self):
        """Handles a login attempt from a POST request."""
        try:
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)
            credentials = parse_qs(post_data.decode('utf-8'))

            username = credentials.get('username', [''])[0]
            password = credentials.get('password', [''])[0]

            with db_connection() as cursor:
                cursor.execute("SELECT id, password_hash FROM users WHERE username = ?", (username,))
                user = cursor.fetchone()

            if user and check_password_hash(user[1], password):
                session_id = secrets.token_hex(16)
                expires_at = datetime.now() + timedelta(days=30)

                with db_connection() as cursor:
                    cursor.execute(
                        "INSERT INTO sessions (session_id, user_id, expires_at) VALUES (?, ?, ?)",
                        (session_id, user[0], expires_at)
                    )

                self.send_response(302)
                self.send_header('Location', '/')
                cookie = SimpleCookie()
                cookie['session_id'] = session_id
                cookie['session_id']['path'] = '/'
                cookie['session_id']['expires'] = expires_at.strftime("%a, %d %b %Y %H:%M:%S GMT")
                self.send_header('Set-Cookie', cookie.output(header='').lstrip())
                self.end_headers()
            else:
                self._send_html_response(401, get_login_page(error="Invalid credentials."))

        except Exception as e:
            logger.error(f"Error during login: {e}")
            self._send_html_response(500, get_login_page(error="Internal server error."))

    def handle_logout(self):
        """Handles logout by deleting the session cookie."""
        cookies = SimpleCookie(self.headers.get('Cookie'))
        session_id = cookies.get('session_id')

        if session_id:
            with db_connection() as cursor:
                cursor.execute("DELETE FROM sessions WHERE session_id = ?", (session_id.value,))

        self.send_response(302)
        self.send_header('Location', '/login')
        self.send_header('Set-Cookie', 'session_id=; Path=/; Max-Age=0') # Delete the cookie
        self.end_headers()

    def serve_homepage(self):
        """Builds and sends the main HTML page.

        Actions:
          - retrieves bookmarks via get_bookmarks()
          - generates HTML with get_html(self, bookmarks)
          - sends HTTP 200 response with Content-Type text/html

        Note: the HTML template is generated by `htmldata.get_html` and can
        contain JS that uses the server-side APIs for CRUD operations.
        """
        # Load only the first "page" of unfiltered bookmarks for initial rendering
        # By default, it hides read items, but this can be overridden by client-side JS
        hide_read_default = True

        bookmarks = self.get_bookmarks(self.get_current_user(), limit=20, offset=0, filter_type=None, hide_read=hide_read_default)

        # The total count always refers to all bookmarks in the DB
        total_count = self.get_total_bookmark_count(filter_type=None, hide_read=False)
        html = get_html(self, bookmarks, __version__, total_count)

        self._send_html_response(200, html)

    def _send_json_response(self, status_code, data):
        """Helper to send JSON responses."""
        self.send_response(status_code)
        self._send_security_headers()
        self.send_header('Content-type', 'application/json; charset=utf-8')
        self.end_headers()
        self.wfile.write(json.dumps(data, ensure_ascii=False).encode('utf-8'))

    def _send_error_response(self, status_code, message):
        """Helper to send error responses in JSON format."""
        error_data = {'error': message}
        self.send_response(status_code)
        self._send_security_headers()
        self.send_header('Content-type', 'application/json; charset=utf-8')
        self.end_headers()
        self.wfile.write(json.dumps(error_data, ensure_ascii=False).encode('utf-8'))

    def serve_static_file(self):
        """Serves a static file from the 'static' folder."""
        try:
            static_path = os.path.join(SCRIPT_DIR, self.path.lstrip('/'))

            # Verify that the resolved path is actually inside the 'static' folder
            # to prevent directory traversal attacks.
            if not os.path.abspath(static_path).startswith(os.path.join(SCRIPT_DIR, 'static')):
                self._send_error_response(403, "Forbidden")
                return

            if os.path.exists(static_path) and os.path.isfile(static_path):
                content_type = 'application/javascript' if static_path.endswith('.js') else 'text/css'
                self.send_response(200)
                self._send_security_headers()
                self.send_header('Content-type', content_type)
                self.end_headers()
                with open(static_path, 'rb') as f:
                    self.wfile.write(f.read())
            else:
                self._send_error_response(404, "Static file not found")

        except Exception as e:
            logger.error(f"Error serving static file {self.path}: {e}")
            self._send_error_response(500, "Internal Server Error")

    def render_bookmarks(self, bookmarks):
        """
        Renders bookmarks as HTML in the "card" view (detailed).

        Input: `bookmarks` is a list of tuples with the form:
            (id, url, title, description, image_url, domain, saved_at, telegram_user_id, telegram_message_id, comments_url, is_read?)

        Output: HTML string representing a sequence of cards. If the list
        is empty, it returns an HTML block indicating there are no bookmarks.

        Note on errors: the method is designed not to raise exceptions
        during rendering; any issues with missing data are
        handled with fallback values (e.g., 'Untitled').
        """
        if not bookmarks:
            return '<div style="text-align: center; color: #666; padding: 40px;">No bookmarks found. Add one!</div>'

        html_cards = []
        for bookmark in bookmarks:
            # bookmark = (id, url, title, description, image_url, domain, saved_at, telegram_user_id, telegram_message_id, comments_url, is_read)

            image_html = ''
            if bookmark[4]:  # image_url
                image_html = f'<img src="{bookmark[4]}" alt="Preview" class="bookmark-image" onerror="this.style.display=\'none\'">'
            else:
                image_html = '<div class="bookmark-image" style="display: flex; align-items: center; justify-content: center; background: #f8f9fa; color: #6c757d;">🔗</div>'

            hn_link = ''
            if bookmark[9]:  # comments_url (HackerNews)
                hn_link = f'<a href="{bookmark[9]}" target="_blank" class="hn-link">🗞️ HN</a>'

            # Sanitize for JS: remove newlines from title and description
            bookmark_list = list(bookmark)
            if bookmark_list[2]: bookmark_list[2] = re.sub(r'[\r\n\u2028\u2029]', ' ', str(bookmark_list[2]))
            if bookmark_list[3]: bookmark_list[3] = re.sub(r'[\r\n\u2028\u2029]', ' ', str(bookmark_list[3]))
            bookmark_safe = tuple(bookmark_list)

            # Create a search string containing all textual data
            search_text = f"{bookmark_safe[1] or ''} {bookmark_safe[2] or ''} {bookmark_safe[3] or ''} {bookmark_safe[5] or ''}".lower()
            search_text = re.sub(r'[\r\n\u2028\u2029]', ' ', search_text)

            # Convert the bookmark tuple to a JSON dictionary for the edit button
            bookmark_json = json.dumps(dict(zip(['id', 'url', 'title', 'description', 'image_url', 'domain', 'saved_at', 'telegram_user_id', 'telegram_message_id', 'comments_url', 'is_read'], bookmark_safe)), ensure_ascii=False)
            bookmark_json_html = bookmark_json.replace("'", "&#39;").replace('"', '&quot;')

            # Logic for the "read" button icon and title
            is_read = bookmark[10] == 1
            read_button_title = "Mark as unread" if is_read else "Mark as read"
            read_button_icon = (
                '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><polyline points="22 4 12 14.01 9 11.01" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></polyline></svg>'
                if is_read
                else '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M20 6L9 17l-5-5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>'
            )

            html_cards.append(f"""
            <div class="bookmark-card" data-id="{bookmark_safe[0]}" data-is-read="{bookmark_safe[10]}" data-search-text="{search_text}">
                <div class="bookmark-header">
                    {image_html}
                    <div class="bookmark-info">
                        <div class="bookmark-actions-top">                            
                            {hn_link}
                            <button class="icon-btn read" title="{read_button_title}" data-id="{bookmark_safe[0]}">{read_button_icon}</button>
                            <button class="icon-btn edit" title="Edit" data-bookmark='{bookmark_json_html}'>
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                            </button>
                            <button class="icon-btn delete" title="Delete" data-id="{bookmark_safe[0]}">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M3 6h18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M8 6v12a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M10 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M14 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                            </button>
                        </div>
                        <div class="bookmark-title">{bookmark_safe[2] or 'Untitled'}</div>
                    </div>
                </div>

                <a href="{bookmark_safe[1]}" target="_blank" class="bookmark-url">{bookmark_safe[1]}</a>

                <div class="bookmark-description">{bookmark_safe[3] or 'No description'}</div>

                <div class="bookmark-footer">
                    <span class="bookmark-date">{bookmark_safe[6]}</span>
                </div>
            </div>
            """)

        return ''.join(html_cards)

    def render_bookmarks_compact(self, bookmarks):
        """
        Renders bookmarks in the compact view (dense list).

        Input and output are similar to `render_bookmarks`, but the markup is more
        compact (fewer details for each item). If the list is empty,
        it returns an informational HTML message.
        """
        if not bookmarks:
            return '<div style="text-align: center; color: #666; padding: 40px;">No bookmarks found. Add one!</div>'

        html_items = []
        for bookmark in bookmarks:
            # bookmark = (id, url, title, description, image_url, domain, saved_at, telegram_user_id, telegram_message_id, comments_url, is_read)

            image_html = ''
            if bookmark[4]:  # image_url
                image_html = f'<img src="{bookmark[4]}" alt="Preview" class="compact-image" onerror="this.innerHTML=\'🔗\'">'
            else:
                image_html = '<div class="compact-image">🔗</div>'

            badges_html = ''
            badges = []
            if bookmark[9]:  # comments_url (HackerNews)
                badges.append(f'<a href="{bookmark[9]}" target="_blank" class="hn-link">HN</a>')

            if badges:
                badges_html = '<div class="compact-badges">' + ''.join(badges) + '</div>'

            # Format the date more compactly
            date_parts = bookmark[6].split(' ')
            short_date = date_parts[0] if len(date_parts) > 0 else bookmark[6]

            # Sanitize for JS: remove newlines from title and description
            bookmark_list = list(bookmark)
            if bookmark_list[2]: bookmark_list[2] = re.sub(r'[\r\n\u2028\u2029]', ' ', str(bookmark_list[2]))
            if bookmark_list[3]: bookmark_list[3] = re.sub(r'[\r\n\u2028\u2029]', ' ', str(bookmark_list[3]))
            bookmark_safe = tuple(bookmark_list)

            # Convert the bookmark tuple to a JSON dictionary for the edit button
            bookmark_json = json.dumps(dict(zip(['id', 'url', 'title', 'description', 'image_url', 'domain', 'saved_at', 'telegram_user_id', 'telegram_message_id', 'comments_url', 'is_read'], bookmark_safe)), ensure_ascii=False)
            bookmark_json_html = bookmark_json.replace("'", "&#39;").replace('"', '&quot;')

            # Logic for the "read" button icon and title
            is_read = bookmark[10] == 1
            read_button_title = "Mark as unread" if is_read else "Mark as read"
            read_button_icon = (
                '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><polyline points="22 4 12 14.01 9 11.01" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></polyline></svg>'
                if is_read
                else '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M20 6L9 17l-5-5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>'
            )

            html_items.append(f"""
            <div class="compact-item" data-id="{bookmark_safe[0]}" data-is-read="{bookmark_safe[10]}">
                {image_html}
                <div class="compact-content">
                    <div class="compact-actions-top">
                        {badges_html}
                        <button class="icon-btn read" title="{read_button_title}" data-id="{bookmark_safe[0]}">{read_button_icon}</button>
                        <button class="icon-btn edit" title="Edit" data-bookmark='{bookmark_json_html}'>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                        </button>
                        <button class="icon-btn delete" title="Delete" data-id="{bookmark_safe[0]}">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M3 6h18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M8 6v12a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M10 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M14 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                        </button>
                    </div>
                    <div class="compact-title">{bookmark_safe[2] or 'Untitled'}</div>
                    <a href="{bookmark_safe[1]}" target="_blank" class="compact-url">{bookmark_safe[1]}</a>
                </div>
                <div class="compact-date">{short_date}</div>
            </div>
            """)

        return ''.join(html_items)

    def serve_bookmarks_api(self, limit=20, offset=0, filter_type=None, hide_read=False, search_query=None):
        """
        API that returns the list of bookmarks in JSON format.

        Actions:
          - retrieves bookmarks with get_bookmarks(), applying filters and search
          - builds a list of dictionaries serializable to JSON
          - sends HTTP 200 response with Content-Type application/json

        Each JSON element contains the keys: id, url, title, description,
        image_url, domain, saved_at, telegram_user_id, telegram_message_id,
        comments_url, is_read.
        """
        bookmarks = self.get_bookmarks(self.get_current_user(), limit=limit, offset=offset, filter_type=filter_type, hide_read=hide_read, search_query=search_query)

        bookmark_list = [] # noqa
        for bookmark in bookmarks:
            bookmark_list.append({
                'id': bookmark[0],
                'url': bookmark[1],
                'title': bookmark[2],
                'description': bookmark[3],
                'image_url': bookmark[4],
                'domain': bookmark[5],
                'saved_at': bookmark[6],
                'telegram_user_id': bookmark[7],
                'telegram_message_id': bookmark[8],
                'comments_url': bookmark[9],
                'is_read': bookmark[10] if len(bookmark) > 10 else 0
            })

        self._send_json_response(200, bookmark_list)

    def delete_bookmark(self, bookmark_id):
        """
        Deletes a bookmark from the database given its `bookmark_id`.

        Responds with JSON:
          - 200 {"status": "deleted"} in caso di successo
          - 500 {"error": "..."} in caso di errore

        Opens an SQLite connection, executes DELETE, and closes the connection.
        """
        try:
            with db_connection() as cursor:
                cursor.execute("DELETE FROM bookmarks WHERE id = ?", (bookmark_id,))
            self._send_json_response(200, {"status": "deleted"})
        except sqlite3.Error as e:
            self._send_error_response(500, str(e))

    def update_bookmark(self, bookmark_id):
        """
        Updates the fields of an existing bookmark.

        Behavior:
          - reads JSON from the request body (Content-Length)
          - only considers allowed fields: url, title, description,
            image_url, comments_url, telegram_user_id, telegram_message_id
          - if `url` is provided, it also updates the `domain` field via extract_domain
          - executes UPDATE on SQLite and responds with 200 on success

        Handled errors:
          - 400 if the body is empty or contains no allowed fields
          - 409 if a uniqueness constraint is violated (URL already exists)
          - 500 for generic errors
        """
        try:
            content_length = int(self.headers.get('Content-Length', 0))
            if content_length == 0:
                self._send_error_response(400, "Request body is empty")
                return

            post_data = self.rfile.read(content_length)
            data = json.loads(post_data.decode('utf-8'))

            fields = {} # noqa
            allowed = ['url', 'title', 'description', 'image_url', 'comments_url', 'telegram_user_id', 'telegram_message_id', 'is_read']
            for k in allowed:
                if k in data:
                    fields[k] = data[k]

            if not fields:
                self._send_error_response(400, "No valid fields to update")
                return

            # If url changed, update domain automatically
            if 'url' in fields:
                fields['domain'] = extract_domain(fields['url'])

            set_clause = ', '.join([f"{k} = ?" for k in fields.keys()])
            params = list(fields.values())
            params.append(bookmark_id)

            with db_connection() as cursor:
                cursor.execute(f"UPDATE bookmarks SET {set_clause} WHERE id = ? AND user_id = ?", params + [self.get_current_user()])

                # After the update, retrieve the updated bookmark to return it
                cursor.execute("""
                    SELECT id, url, title, description, image_url, domain,
                        datetime(saved_at, 'localtime') as saved_at,
                        telegram_user_id, telegram_message_id, comments_url,
                        COALESCE(is_read, 0) as is_read
                    FROM bookmarks WHERE id = ?
                """, (bookmark_id,))
                updated_bookmark_tuple = cursor.fetchone()

            if not updated_bookmark_tuple:
                self._send_error_response(404, "Bookmark not found after update")
                return

            updated_bookmark = dict(zip(['id', 'url', 'title', 'description', 'image_url', 'domain', 'saved_at', 'telegram_user_id', 'telegram_message_id', 'comments_url', 'is_read'], updated_bookmark_tuple))
            self._send_json_response(200, updated_bookmark)
        except sqlite3.IntegrityError:
            self._send_error_response(409, "URL already exists")
        except Exception as e:
            logger.error(f"Error updating bookmark {bookmark_id}: {e}")
            self._send_error_response(500, "An internal error occurred")

    def mark_read(self, bookmark_id):
        """
        Sets the `is_read` flag for a bookmark.

        Behavior:
          - optionally reads JSON from the body with the key 'is_read' (true/false)
          - if not provided, sets is_read = 1 (read)
          - updates the record in the DB and responds with JSON containing the resulting state: {"status": "ok", "is_read": <0|1>}

        Responds with 500 with the error message in case of an error.
        """
        try:
            # Reads the request body to determine the desired state.
            # If the body is absent, the default action is to mark as read (is_read=1).
            content_length = int(self.headers.get('Content-Length', 0))
            is_read = 1
            if content_length > 0:
                post_data = self.rfile.read(content_length)
                data = json.loads(post_data.decode('utf-8'))
                if 'is_read' in data:
                    is_read = 1 if data.get('is_read') else 0

            with db_connection() as cursor:
                cursor.execute("UPDATE bookmarks SET is_read = ? WHERE id = ? AND user_id = ?", (int(is_read), bookmark_id, self.get_current_user()))
            self._send_json_response(200, {'status': 'ok', 'is_read': is_read})

        except sqlite3.Error as e:
            self._send_error_response(500, str(e))

    def add_bookmark(self):
        """
        Adds a new bookmark to the database by reading JSON from the body.

        Expected fields in JSON: url (required), title, description,
        image_url, telegram_user_id, telegram_message_id, comments_url.

        Behavior:
          - validates the presence of the url
          - automatically extracts and saves the domain
          - checks for uniqueness constraint on the URL -> responds 409 if it already exists
          - inserts the record and responds with 201 on success

        Handled errors: 400 (bad request), 409 (duplicate URL), 500 (other)
        """
        try:
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data.decode('utf-8'))

            url = data.get('url', '').strip()
            if not url:
                raise ValueError("URL is required")

            user_id = self.get_current_user()
            # Extract domain automatically
            domain = extract_domain(url)

            with db_connection() as cursor:
                # Check if URL already exists for this user
                cursor.execute("SELECT id FROM bookmarks WHERE url = ? AND user_id = ?", (url, user_id))
                if cursor.fetchone():
                    self._send_error_response(409, "URL already exists")
                    return

                cursor.execute("""
                    INSERT INTO bookmarks (user_id, url, title, description, image_url, domain, telegram_user_id, telegram_message_id, comments_url)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    user_id,
                    url,
                    data.get('title'),
                    data.get('description'),
                    data.get('image_url'),
                    domain,
                    data.get('telegram_user_id') if data.get('telegram_user_id') else None,
                    data.get('telegram_message_id') if data.get('telegram_message_id') else None,
                    data.get('comments_url')
                ))

            self._send_json_response(201, {"status": "created"})

        except ValueError as e:
            self._send_error_response(400, str(e))
        except sqlite3.IntegrityError:
            self._send_error_response(409, "URL already exists")
        except Exception as e:
            logger.error(f"Error adding bookmark: {e}")
            self._send_error_response(500, "An internal error occurred")

    def scrape_metadata(self):
        """
        Scrapes metadata from a URL provided in the request body.
        """
        try:
            content_length = int(self.headers.get('Content-Length', 0))
            if content_length == 0:
                self._send_error_response(400, "Request body is empty")
                return

            post_data = self.rfile.read(content_length)
            data = json.loads(post_data.decode('utf-8'))
            url = data.get('url')

            if not url:
                self._send_error_response(400, "URL is required")
                return

            metadata = get_article_metadata(url)
            self._send_json_response(200, metadata)

        except Exception as e:
            logger.error(f"Error scraping metadata for URL {data.get('url', '')}: {e}")
            self._send_error_response(500, "Failed to scrape metadata")

    def get_total_bookmark_count(self, filter_type=None, hide_read=False):
        """Retrieves the total number of bookmarks from the database."""
        try:
            with db_connection() as cursor:
                query, params = self._build_query_parts(self.get_current_user(), filter_type, hide_read)
                cursor.execute(f"SELECT COUNT(*) FROM bookmarks WHERE {query}", params)
                count = cursor.fetchone()[0]
            return count
        except sqlite3.Error as e:
            logger.error(f"Database error during count: {e}")
            return 0

    def _build_query_parts(self, user_id, filter_type=None, hide_read=False, search_query=None):
        """
        Builds the WHERE clauses and parameters for bookmark queries.
        Args:
            user_id (int): The ID of the current user.
            filter_type (str, optional): Filter for 'telegram', 'hn', 'recent'.
            hide_read (bool, optional): If True, excludes read bookmarks.
            search_query (str, optional): Text search term.

        Returns:
            tuple: A string with the WHERE clauses and a list of parameters.
        """
        where_clauses = ["user_id = ?"]
        params = [user_id]

        if filter_type == 'recent':
            where_clauses.append("saved_at >= datetime('now', '-7 days')")

        if hide_read:
            where_clauses.append("is_read = 0")

        if search_query:
            where_clauses.append("(title LIKE ? OR description LIKE ? OR url LIKE ? OR domain LIKE ?)")
            params.extend([f'%{search_query}%'] * 4)

        return " AND ".join(where_clauses), params

    def get_bookmarks(self, user_id, limit=20, offset=0, filter_type=None, hide_read=False, search_query=None):
        """
        Retrieves bookmarks from the database, applying optional filters and search.
        """
        try:
            with db_connection() as cursor:
                where_clause, params = self._build_query_parts(user_id, filter_type, hide_read, search_query)

                cursor.execute("""
                    SELECT id, url, title, description, image_url, domain,
                        datetime(saved_at, 'localtime') as saved_at,
                        telegram_user_id, telegram_message_id, comments_url,
                        COALESCE(is_read, 0) as is_read
                    FROM bookmarks
                    WHERE {where_clause}
                    ORDER BY saved_at DESC
                    LIMIT ? OFFSET ?
                """.format(where_clause=where_clause), params + [limit, offset])

                bookmarks = cursor.fetchall()
            return bookmarks

        except sqlite3.Error as e:
            logger.error(f"Database error fetching bookmarks: {e}")
            return []

def create_self_signed_cert(cert_file_path, key_file_path):
    """
    Creates a self-signed certificate (if it doesn't exist) using OpenSSL.

    Produces two files: KEY_FILE (private key) and CERT_FILE (certificate).
    If OpenSSL is not available or the command fails, execution terminates.
    """
    # This function requires 'openssl' in the system's PATH
    import subprocess
    if os.path.exists(cert_file_path) and os.path.exists(key_file_path):
        logger.info(f"Existing certificates found: {cert_file_path}, {key_file_path}")
        return

    logger.info("Creazione certificato self-signed con chiave RSA 2048-bit...")

    try:
        # First, generate the 2048-bit RSA private key
        subprocess.run([
            'openssl', 'genrsa',
            '-out', key_file_path,
            '2048'
        ], check=True, capture_output=True)

        # Then, generate the certificate
        subprocess.run([
            'openssl', 'req', '-new', '-x509',
            '-key', key_file_path,
            '-out', cert_file_path,
            '-days', '365',
            '-subj', '/C=IT/ST=Italy/L=Rome/O=LocalServer/CN=localhost'
        ], check=True, capture_output=True)
        logger.info("✅ Certificate created successfully!")

    except subprocess.CalledProcessError as e:
        logger.error(f"❌ Error creating certificate: {e}")
        sys.exit(1)
    except FileNotFoundError:
        logger.error("❌ OpenSSL not found in the system's PATH")
        sys.exit(1)

def main():
    """
    Main entry-point that starts the HTTPS server.

    Main actions:
      - initializes the DB (init_database)
      - configures HTTPServer and TLS
      - starts the serve_forever loop

    Handles KeyboardInterrupt to shut down the server gracefully.
    """
    # --- Certificate Logic ---
    le_domain = os.getenv('LE_DOMAIN', None)
    logger.info(f"LE_DOMAIN letto come '{le_domain}'")

    if le_domain:
        # Standard path for Let's Encrypt certificates in a Linux/Docker environment
        le_cert_dir = f'/etc/letsencrypt/live/{le_domain}'
        le_fullchain = os.path.join(le_cert_dir, 'fullchain.pem')
        le_privkey = os.path.join(le_cert_dir, 'privkey.pem')

        if os.path.exists(le_fullchain) and os.path.exists(le_privkey):
            logger.info(f"Found Let's Encrypt certificates: {le_cert_dir}")
            cert_file = le_fullchain
            key_file = le_privkey
        else:
            logger.warning(f"LE_DOMAIN is set but certificates were not found or are not readable in {le_cert_dir}")
            logger.warning("Check permissions or path. Proceeding with local certificates.")
    else:
        # LE_DOMAIN is not set, using local self-signed certificates.
        logger.info("LE_DOMAIN not set. Using local certificates.")
        cert_dir = os.path.join(SCRIPT_DIR, 'certs')
        os.makedirs(cert_dir, exist_ok=True)
        cert_file = os.path.join(cert_dir, 'server.pem')
        key_file = os.path.join(cert_dir, 'server.key')

        # Create certificate if necessary
        if not (os.path.exists(cert_file) and os.path.exists(key_file)):
            create_self_signed_cert(cert_file, key_file)

    # Configure the server
    server_address = ('', PORT)
    httpd = HTTPServer(server_address, BookmarkHandler)

    # Configure SSL
    try:
        context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
        context.minimum_version = ssl.TLSVersion.TLSv1_2
        context.load_cert_chain(cert_file, key_file)
        httpd.socket = context.wrap_socket(httpd.socket, server_side=True)
    except ssl.SSLError as e:
        logger.error(f"❌ Errore SSL: {e}")
        return

    # Get the local IP
    try:
        hostname = socket.gethostname()
        local_ip = socket.gethostbyname(hostname)
    except Exception:
        local_ip = "IP_NOT_AVAILABLE"

    logger.info(f"""
🚀 HTTPS Server started!

📍 Access from:
   • https://www.mydomain.com:{PORT}
   • https://127.0.0.1:{PORT}
   • https://{local_ip}:{PORT}

📁 Database: {os.path.abspath(DB_PATH)}
🔒 Certificate: {os.path.abspath(cert_file)}

✨ NEW FEATURES:
   • ➕ Hidden form (show on request)
   • 📋 Cards View (detailed)
   • 📄 Compact View (dense list)
   • 🔍 Search and filters for both views
   • 📱 Telegram Integration
   • 🗞️ HackerNews Links

Press Ctrl+C to stop the server.
    """)

    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        logger.info("\n🛑 Server stopped gracefully")
        httpd.shutdown()

if __name__ == '__main__':
    # Add the project root to the path to import the shared library
    sys.path.append(os.path.dirname(SCRIPT_DIR))
    try:
        # Directly import the DB initialization function
        from shared.database import init_database
        logger.info("Initializing database...")
        init_database()
        
        # Start the server
        main()

    except ImportError:
        logger.error("ERROR: Could not import database logic. Make sure the project structure is correct.")
        sys.exit(1)
    except Exception as e:
        logger.critical(f"Unexpected ERROR during startup: {e}")
        sys.exit(1)
